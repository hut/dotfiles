set nocompatible

" Hostname-based settings
if $HOSTNAME =~ "^lem"
    " Terminal-related
    if has('nvim')
        tnoremap <C-W> <C-\><C-n><C-W>
        tnoremap <S-Tab> <C-\><C-n><S-Tab>
        map <A-Enter> <ESC>:terminal<CR>
        map <C-b> <ESC>:tab new term://bash<CR>i
        let g:terminal_scrollback_buffer_size = 100000
        let $NVIM_TUI_ENABLE_CURSOR_SHAPE = 0
    endif

    " Styling
    "colorscheme default
    "set fillchars+=vert:\ 

    set nofoldenable

    " Plugins
    filetype off
    set rtp+=~/.vim/bundle/Vundle.vim

    call vundle#begin()
    Plugin 'VundleVim/Vundle.vim'
    Plugin 'https://github.com/vimwiki/vimwiki.git'
    Plugin 'https://github.com/majutsushi/tagbar.git'
    Plugin 'https://github.com/ctrlpvim/ctrlp.vim.git'
    "Plugin 'https://github.com/davidhalter/jedi-vim.git'
    Plugin 'https://github.com/MarcWeber/vim-addon-mw-utils.git'
    Plugin 'https://github.com/tomtom/tlib_vim.git'
    Plugin 'https://github.com/garbas/vim-snipmate.git'
    Plugin 'https://github.com/Konfekt/FastFold.git'
    Plugin 'https://github.com/tmhedberg/SimpylFold'
    Plugin 'https://github.com/nelstrom/vim-markdown-folding.git'
    Plugin 'https://github.com/jceb/vim-orgmode.git'
    "Plugin 'https://github.com/universal-ctags/ctags'
    call vundle#end()

    filetype plugin indent on

    let g:ctrlp_cmd = 'CtrlP /projects'
    let g:ctrlp_map = '<space>'
    let g:ctrlp_extensions = ['line', 'dir']

    let g:jedi#use_tabs_not_buffers = 1
    let g:jedi#completions_enabled = 0
    let g:jedi#documentation_command = "\\D"
    let g:jedi#goto_assignments_command = "\\a"
    let g:jedi#goto_definitions_command = "\\d"
    let g:jedi#usages_command = "\\u"

    let g:vimwiki_folding = 'expr'
    let g:vimwiki_list = [{'path': '~/hut/git/vimwiki/'}]
else
    " Highlight long lines
    au Filetype * call SetOverLengthHighlight()
    fun! SetOverLengthHighlight()
    "    highlight OverLength ctermbg=darkred ctermfg=white
    "    syntax match OverLength /\%80v.\+/
        highlight BlankLine ctermbg=darkgrey ctermfg=white
        syntax match BlankLine /^\s\+$/
    endfun
    call SetOverLengthHighlight()

    if $HOSTNAME == "fez"
        filetype off
        set rtp+=~/.config/nvim/bundle/Vundle.vim
        call vundle#begin()

        Plugin 'majutsushi/tagbar'
        Plugin 'gmarik/Vundle.vim'
        Plugin 'MarcWeber/vim-addon-mw-utils'
        Plugin 'tomtom/tlib_vim'
        Plugin 'garbas/vim-snipmate'
        "Plugin 'honza/vim-snippets'
        Plugin 'tikhomirov/vim-glsl'
        Plugin 'mrk21/yaml-vim'
        "Plugin 'rkulla/pydiction'
        Plugin 'scrooloose/syntastic'
        Plugin 'airblade/vim-gitgutter'
        Plugin 'vimwiki/vimwiki'
        Plugin 'kien/ctrlp.vim'
        Plugin 'scrooloose/nerdtree'
        Plugin 'dhruvasagar/vim-dotoo'
        "Plugin 'hut/vim-orgmode'
        Plugin 'dkarter/bullets.vim'
        "Plugin 'Konfekt/FastFold'
        "Plugin 'vim-scripts/utl'

        call vundle#end()

        " --- Settings for Plugin "dotoo" ---
        autocmd BufNewFile,BufRead editor-*.txt setf markdown
        autocmd BufNewFile,BufRead *.org setf dotoo
        hi clear dotoo_italic
        let g:dotoo_todo_keyword_faces = [
          \ ['TODO', [':foreground 160', ':weight bold']],
          \ ['NEXT', [':foreground 27', ':weight bold']],
          \ ['DONE', [':foreground 22', ':weight bold']],
          \ ['WAITING', [':foreground 202', ':weight bold']],
          \ ['IN-PROGRESS', [':foreground 155', ':weight bold']],
          \ ['HOLD', [':foreground 53', ':weight bold']],
          \ ['CANCELLED', [':foreground 22', ':weight bold']],
          \ ]
        let g:dotoo#parser#todo_keywords = [
          \ 'TODO',
          \ 'NEXT',
          \ 'WAITING',
          \ 'HOLD',
          \ 'IN-PROGRESS',
          \ '|',
          \ 'CANCELLED',
          \ 'DONE']

        " --- Settings for Plugin "bullet.vim" ---
        let g:bullets_enabled_file_types = ['markdown', 'text', 'gitcommit', 'dotoo', 'tex']

        let g:ctrlp_map = 'B'
        map <A-`> :NERDTreeToggle<CR>
        let g:NERDTreeDirArrowExpandable = '>'
        let g:NERDTreeDirArrowCollapsible = 'v'
        let NERDTreeIgnore=['\.pyc$', '\~$']

        let g:syntastic_python_checkers = ['pylint']
        "let g:syntastic_python_checkers = []

        let g:org_todo_keywords = ['TODO', 'NEXT', 'IN-PROGRESS', 'WAITING', '|', 'DONE']
        let g:org_agressive_conceal = 1

        let g:markdown_folding=1

        let g:pydiction_location = '/home/hut/.config/nvim/bundle/pydiction/complete-dict'
        "let g:vimwiki_folding = 'list'
        "set statusline+=%#warningmsg#
        "set statusline+=%{SyntasticStatuslineFlag()}
        "set statusline+=%*
        ""let g:syntastic_always_populate_loc_list = 1
        ""let g:syntastic_auto_loc_list = 1
        "let g:syntastic_check_on_open = 1
        "let g:syntastic_python_python_exec = '/usr/bin/python3'
        filetype plugin indent on
        filetype plugin on

        let g:syntastic_python_pylint_args = '--rcfile=/home/hut/.pylintrc'
        "let g:syntastic_python_pylint_post_args = ['--version']
        let g:hutsnip_path = '/home/hut/sync/notes/quick/snippets'

        for f in split(glob(g:hutsnip_path . '/*'), '\n')
            let basename = substitute(f, '.*/\([^/]*\)$', '\1', '')
            exec "map \\\\" . basename . " <ESC>:.-1r " . f . "<CR>i"
        endfor

        "imap <silent><buffer> <S-Tab> <Plug>VimwikiDecreaseLvlSingleItem
        "imap <silent><buffer> <Tab> <Plug>VimwikiIncreaseLvlSingleItem
        map \w_n <Plug>VimwikiNextLink
        map \w_p <Plug>VimwikiPrevLink

        function! EfFive()
            silent w
            if expand("%:e") == "dot"
                call system("gvpr -c 'N[$.indegree==0]{subnode(isSubg($G, \"next\"),$);} N[$.height==\"0\"]{delete(0,$);}' " . expand("%") . " 2> /tmp/f5.stderr | tee /tmp/f5.stdout | dot -Tpng -o /tmp/f5out.png && firefox /tmp/f5out.png")
            endif
            return ""
        endfunction
        map  \wr  :call EfFive()<CR>
        map  <F5> :call EfFive()<CR>
        imap <F5> <C-R>=EfFive()<CR>

        nnoremap <space> za

        "ino <tab> <C-r>=TriggerSnippet()<CR>
        "snor <tab> <ESC>i<right><C-r>=TriggerSnippet()<CR>
    endif

    " Don't need this on lemming
    fun! DecideIfShouldUseTab()
        let lnum = 1
        while lnum <= 200
            let lnum = lnum + 1
            let line = getline(lnum)
        let got_spaces = 0
            if line =~ "^\t\t"
                call UseTabs()
                return
            endif
            if line =~ "^    "
          let got_spaces = 1
            endif
        endwhile
      if got_spaces
        call UseSpaces()
      endif
    endfun
    au Filetype * call DecideIfShouldUseTab()
endif

" Common Plugin settings
let g:vimwiki_list = [{
    \ 'path': '~/sync/notes/vimwiki/',
    \ 'syntax': 'markdown',
    \ 'ext': '.md',
    \ }]
let g:vimwiki_folding = 'expr'
let g:vimwiki_hl_cb_checked = 2

" Styling
colorscheme jungle
set fillchars=vert:â”‚,fold:\ 

set viminfo='100,<0,s10,h
set modeline

set lcs=tab:^\ ,trail:'

set mouse=a
set showcmd
set ruler
set hidden
set title

set incsearch
"set foldmethod=indent
"set foldlevel=2
"set foldnestmax=2
set scrolloff=4

set shortmess=IaWTF
let g:bufferline_echo=0

set formatoptions-=r,o
set nohlsearch
set wildmenu

set ignorecase
set smartcase
set smartindent
set backupdir=~/.vim/swap,/var/tmp,/tmp
set directory=~/.vim/swap,/var/tmp,/tmp

"set foldmethod=indent
set foldmethod=marker

iab Zabc abcdefghijklmnopqrstuvwxyz

if has("autocmd")
    autocmd FileType python set complete+=k~/.vim/complete-dict "isk+=.,(
    autocmd FileType org set ft=dotoo
    "autocmd FileType python nnoremap <buffer> [[ ?^\*class\\|^\s*def<CR>
    "autocmd FileType python nnoremap <buffer> [[ /^\*class\\|^\s*def<CR>
endif " has("autocmd"

" Tabs / Spaces {{{
map -<TAB>   :set sw=4 ts=4 sts=4 noexpandtab<CR>
map -1       :set sw=1 ts=1 sts=1 expandtab<CR>
map -2       :set sw=2 ts=2 sts=2 expandtab<CR>
map -3       :set sw=3 ts=3 sts=3 expandtab<CR>
map -4       :set sw=4 ts=4 sts=4 expandtab<CR>
map -<SPACE> :set sw=4 ts=4 sts=4 expandtab<CR>

fun! UseTabs()
    set shiftwidth=4
    set tabstop=4
    set softtabstop=4
    set noexpandtab
endfun

fun! UseSpaces()
    set shiftwidth=4
    set tabstop=4
    set softtabstop=4
    set expandtab
endfun

call UseSpaces()

fun! ToggleTabsSpaces()
  if &expandtab
    call UseTabs()
    echo "using tabs!"
  else
    call UseSpaces()
    echo "using spaces!"
  endif
endfun

au BufRead *.texx setf tex

"fun! Ranger()
""    silent !/home/hut/ranger/ranger.py --choosefile=/tmp/rangerchoose `[ -z '%' ] && echo -n . || dirname %`
"    exec "silent !/home/hut/ranger/ranger.py --choosefile=/tmp/chosenfile " . expand("%:p:h")
"  if filereadable('/tmp/rangerchoose')
"    exec 'edit ' . system('cat /tmp/rangerchoose')
"    call system('rm /tmp/rangerchoose')
"  endif
"    redraw!
"endfun

"fun! RangerChooser()
"    exec "silent !ranger --choosefile=/tmp/chosenfile " . expand("%:p:h")
"    if filereadable('/tmp/chosenfile')
"        exec 'edit ' . system('cat /tmp/chosenfile')
"        call system('rm /tmp/chosenfile')
"    endif
"    redraw!
"endfun

map ,T :call UseTabs()<CR>
map ,s :call UseSpaces()<CR>
"map ,r :call RangerChooser()<CR>
" }}}

" Mappings {{{

" Tabs
noremap <tab> gt
noremap <S-tab> gT
map <C-n> :tabnew<cr>

" bla
map <F12> :TagbarToggle<CR>
map ,m :silent !markdown % > %.html<CR>
map ,p :set paste!<CR>:set ruler<CR>:echo "paste =" &paste<CR>
map ,T :edit ~/me/notes/org/projects.org<CR>
map ,b :source ~/.vimrc<cr>
map ,B :e ~/.vimrc<cr>
map ,w :e <C-r>=substitute(@%, '^\(.*/\).*$', '\1', '')<cr><cr>
map ,e :e.<cr>
map ,SE :set spell spelllang=en_us<CR>
map ,SD :set spell spelllang=de<CR>
map ,SS :set nospell<CR>
map ,H :silent !echo -ne "\033]12;black\007"<CR>:autocmd VimLeave * silent !echo -ne "\033]12;white\007"<CR>:set noruler<CR>
map ,fs :%s/\s\+$//e<CR>:%s/\t/    /ge<CR>
vmap ,fs :s/\s\+$//e<CR>gv:s/\t/    /ge<CR>gv
map \k :mksession! ~/Session.vim<CR>
map ,R :execute '!echo ' . v:servername . ' > /tmp/nvimserver'<CR>
map ,g :GitGutterToggle<CR>
map ,ts :SyntasticToggleMode<CR>
map -S :set wrap!<CR>
map -l :set list!<CR>
map ,> :s/^\*/**/<CR>
map ,< :s/^\*//<CR>

map go :call NewHeader()<CR>kA

fun! NewHeader()
    let l:bullets = matchend(getline('.'), '*\+')
    let l:regex = '^\*\{1,' . l:bullets . '} '
    let l:insert = repeat('*', l:bullets) . ' '

    call search(l:regex, 'W')
    call append(line('.')-1, l:insert)
    "let l:bullets_regex = '^' . substitute(l:bullets, '*', '\\*', 'g')
    "call search(l:bullets_regex, 'W')
endfun

noremap <C-p> <tab>
noremap <CR> :nohlsearch<CR><CR>

" avoid typos
map Q <ESC>
map ; :
"map <F1> <ESC>
"imap <F1> <ESC>
"vmap <F1> <ESC>
command! W w
command! Q q
command! Wq wq
command! WQ wq
map U <C-R>

" Shortcuts
vnoremap < <gv
vnoremap > >gv
map gV ggVG
map s :s/
map S :%s/
map b :b 
vmap S :s/
inoremap <F9>  <C-R>=strftime("%Y/%m/%d %H:%M ")<CR>
inoremap <F10> <C-R>=strftime("%s ")<CR>
inoremap <F11> <C-R>=printf("0x%X", strftime("%s"))<CR>

" Movement
imap <C-h> <LEFT>
imap <C-l> <RIGHT>
noremap H 10h
noremap J 20j
noremap K 20k
noremap L 10l
noremap <C-j> J
imap <C-j> <DOWN>
imap <C-k> <UP>

" }}}

" modify external scripts {{{
let loaded_matchparen = 1
let g:netrw_list_hide="\\.py[co]$,^\\."
let python_highlight_numbers = 1
let python_highlight_builtins = 1
let python_highlight_builtins = 1
" }}}

"source ~/.vim/plugin/speeddating.vim
au Filetype *.org source ~/.vim/syntax/vorg.vim
au BufRead *.pen setf python
syntax on
filetype indent plugin on

au BufReadPost * call CheckForMaxima()
fun! CheckForMaxima()
    if substitute(getreg('%'), '^.*\.', '', '') == 'maxima'
        set ft=maxima
    endif
endfun

inoremap # x#
" Automatic compilation {{{

" Compile + Run Project
"imap <F3> <ESC>:call Compilef5(2)<CR>
"map  <F3> :call Compilef5(2)<CR>

" Run Project
"imap <F4> <ESC>:call Compilef5(3)<CR>
"map  <F4> :call Compilef5(3)<CR>
"map <F5> :e %:p:s,.h$,.X123X,:s,.cpp$,.h,:s,.X123X$,.cpp,<CR>
"imap <F5> <ESC>:e %:p:s,.h$,.X123X,:s,.cpp$,.h,:s,.X123X$,.cpp,<CR>

" Compile + Run File
"imap <F5> <ESC>:call Compilef5(0)<CR>
"map  <F5> :call Compilef5(0)<CR>

" Run File
"imap <F6> <ESC>:call Compilef5(1)<CR>
"map  <F6> :call Compilef5(1)<CR>

"map gR :silent w<CR>:call system("/home/hut/code/pendulum/pendulum.py " . @%)<cr>
"map g<c-r> :w<CR>:silent !/home/hut/code/pendulum/pendulum.py % &<cr><c-l>
"map gr :silent call Compilef5(2)<CR><c-l>
"map gr :!cd ~/pull/atmega/stuff; make; sudo make flash<CR>
"map gr :call Compilef5(0)<CR>
"map gR :w<CR>:silent !./% &<cr><c-l>
"map gr :w<CR>:silent call system("ps a \| grep [p]ython.*pendulum \| sed 's/^[^0-9]*\\([0-9]\\+\\).*$/\\1/;' \| xargs kill -SIGUSR1 &")<cr>:echo ""<cr>

" The function
function! Compilef5(mode)
    silent w
    if a:mode == 0
        !rifle -p compile %
    elseif a:mode == 1
        !pile -r %
    elseif a:mode == 2
        if &ft == 'actionscript'
            call system("pile -m ". @%)
        else
            !pile -m %
        endif
    elseif a:mode == 3
        if &ft == 'actionscript'
            call system("pile -r -m ". @%)
        else
            !pile -r -m %
        endif
    endif
endfunction
" }}}

" Command "DiffWithSaved" {{{
function! s:DiffWithSaved()
  let filetype=&ft
  diffthis
  vnew | r # | normal! 1Gdd
  diffthis
  exe "setlocal bt=nofile bh=wipe nobl noswf ro ft=" . filetype
endfunction
com! DiffSaved call s:DiffWithSaved()
" }}}
" nice fold text {{{
set foldtext=GetFoldText()
fun! GetFoldText()
    return substitute(
        \substitute(
            \getline(v:foldstart),
            \"    ",
            \repeat(' ', &ts),
            \"g"),
        \'\('.b:cmchr.'\)*{{'.'{\d*',
        \'- '.(v:foldend-v:foldstart).'l',
        \'')
    let l:line = substitute(l:line, '^\*+', ' ')
    return l:line
endfun
" }}}
" comments {{{

if(!exists('b:cmchr')) | let b:cmchr = '#' | endif

map ,f :call ToggleComment(0,2)<CR>
vmap ,f :call ToggleComment(1,2)<CR>gv

au Filetype * call GetCommentCharacter()

fun! ToggleComment(range, mode)
"   Range Values:
"   0: Normal Mode (1 line), 1: Visual Mode (range)
"   Mode Vaules:
"   0: uncomment, 1: comment, 2: toggle

    if a:range
        if line('.') != line("'<") | return | endif
        if a:mode==0 || (a:mode==2 &&
                    \getline("'<") =~ '^\s*'.b:cmchr.'\s*[^{]')
            silent execute "'<,'>s".'/^\(\s*\)'.b:cmchr.'/\1/'
        else
            silent execute "'<,'>s/^/".b:cmchr.'/'
        endif
    else
        let l = getline('.')
        if a:mode==0 || (a:mode==2 &&
                    \(l =~ '{'.'{{') ?
                    \(l =~ '^\s*'.b:cmchr.'\{3,999}') :
                    \(l =~ '^\s*'.b:cmchr))
            silent execute 's/^\(\s*\)'.b:cmchr.'/\1/'
            echo 'Uncommented.'
        else
            silent execute 's/^/'.b:cmchr.'/'
            echo 'Inserted Comment.'
        endif
    endif
endfun

fun! GetCommentCharacter()
    let b:cmchr = '#'
    if &filetype == "asm"
        let b:cmchr = ";"
    elseif &filetype == "php"
        let b:cmchr = '\/\/'
    elseif &filetype == "java"
        let b:cmchr = '\/\/'
    else
        let test = substitute(&comments, '^.*:\([^:]*\)$', '\1', '')
        if test != &comments && test != '-'
            let b:cmchr = escape(test, '/')
        endif
    end
endfunction

" }}}

"
"function! InstallPythonFold()
"    " Only do this when not done yet for this buffer
"    if exists("b:did_ftplugin")
""    finish
"    endif
"    let b:did_ftplugin = 1
"
"    map <buffer> <S-e> :w<CR>:!/usr/bin/env python % <CR>
"    map <buffer> gd /def <C-R><C-W><CR>
"
"    set foldmethod=expr
"    set foldexpr=PythonFoldExpr(v:lnum)
"    set foldtext=PythonFoldText()
"
"    map <buffer> f za
"    map <buffer> F :call ToggleFold()<CR>
"    let b:folded = 1
"
"    function! ToggleFold()
"        if( b:folded == 0 )
"            exec "normal! zM"
"            let b:folded = 1
"        else
"            exec "normal! zR"
"            let b:folded = 0
"        endif
"    endfunction
"
"    function! PythonFoldText()
"        if match(getline(v:foldstart), '[a-zA-Z]') >= 0
"            let line = v:foldstart
"        else
"            let line = v:foldstart + 1
"        endif
"        if match(getline(line), '"""') >= 0
"            let text = substitute(getline(line), '"""', '', 'g' )
"        elseif match(getline(line), "'''") >= 0
"            let text = substitute(getline(line), "'''", '', 'g' )
"        else
"            let text = getline(line)
"        endif
"
"        return '  ' . text
"    endfunction
"
"    function! PythonFoldExpr(lnum)
"        if indent( nextnonblank(a:lnum) ) == 0
"            return 0
"        endif
"
"        if getline(a:lnum-1) =~ '^\(class\|def\)\s'
"            return 1
"        endif
"
"        if getline(a:lnum) =~ '^\s*$'
"            return "="
"        endif
"
"        if indent(a:lnum) == 0
"            return 0
"        endif
"
"        return '='
"    endfunction
"
"    " In case folding breaks down
"    function! ReFold()
"        set foldmethod=expr
"        set foldexpr=0
"        set foldnestmax=1
"        set foldmethod=expr
"        set foldexpr=PythonFoldExpr(v:lnum)
"        set foldtext=PythonFoldText()
"        echo
"    endfunction
"endfunction
"autocmd FileType python call InstallPythonFold()

"map <F1> $?^$<cr>jV/^$<cr>k!texin<cr>u
imap ,m \vec{\mathbf{
imap ,v \vec{
map \s :SnipMateOpenSnippetFiles<CR>

map g/., :w ~/sync/ramblings/<C-R>=strftime("%Y-%m-%d_%H%M%S")<CR>_<C-r>=$USER<CR>_<C-r>=hostname()<CR>.txt<CR>ggdG:w<CR>

let g:hut_projectpath = '/home/hut/sync/notes/vimwiki/tasks/'
let g:hut_indexpath = '/home/hut/sync/notes/vimwiki/tasks/tasks.wiki'
function! NewProject()
	call inputsave()
	let name = input('Task name: ')
	call inputrestore()
	if strlen(name) > 0
		let fullname = strftime('%Y-%m-%d_').  name
		execute "silent !echo '- [ ] [[" . substitute(fullname, "'", "'\\\\''", '') . "]]' >> '" . g:hut_indexpath . "'"
		execute 'edit '.fnameescape(g:hut_projectpath . fullname . '.wiki')
	endif
endfun
nmap \wc :call NewProject()<CR>

if filereadable(glob("~/.vimrc.local"))
    source ~/.vimrc.local
endif
