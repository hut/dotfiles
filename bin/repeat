#!/usr/bin/python
"""
Track tasks which have to be done repeatedly.

A bashrc entry for doing a weekly task could look like this:

if repeat -l mytask; then echo DO YOUR TASK; fi;
function domytask () { repeat -l mytask -d 7; };

if repeat --quiet; then echo "you need to do: $(repeat)"; fi;
"""
import argparse
import csv
import datetime
import os.path
import sys
from dateutil.relativedelta import relativedelta
from dateutil.parser import parse as parse_date

REPEATFILE = os.path.expanduser("~/repeat")
FIELDS = ['label', 'date', 'count', 'last_step', 'finished']
DAY_STARTS_AT = 6
PRETTY_COLORS = '102 138 174 209 215'.split()

def db_read(csvfile):
    data = {}
    with open(csvfile, "r") as f:
        for entry in csv.DictReader(f):
            data[entry['label']] = entry
    return data


def db_write(csvfile, data):
    # rename csvfile instead overwriting to prevent data loss when disk is full
    suffix = '_write_tmp'
    os.rename(csvfile, csvfile + suffix)
    with open(csvfile, "w") as f:
        dictwriter = csv.DictWriter(f, fieldnames=FIELDS)
        dictwriter.writeheader()
        dictwriter.writerows(data.values())
    os.rename(csvfile + suffix, csvfile)


def date_offset(offset):
    today = datetime.date.today()
    return today + relativedelta(days=int(offset))


def main():
    parser = argparse.ArgumentParser(description=sys.modules[__name__].__doc__.strip())
    parser.add_argument('-v', '--verbose', action='store_true', default=False)
    parser.add_argument('-q', '--quiet', action='store_true', default=False)
    parser.add_argument('--pretty', action='store_true', default=False)
    parser.add_argument('-l', '--label', type=str)
    parser.add_argument('-d', '--days', type=int)
    parser.add_argument('--file', type=str, default=REPEATFILE)
    args = parser.parse_args()

    try:
        db = db_read(args.file)
    except IOError:
        db = dict()

    today = datetime.date.today()
    now = datetime.datetime.now()
    now_compare = now - relativedelta(hours=DAY_STARTS_AT)

    if args.label is None:
        items = [entry['label'] for entry in db.values() \
                if parse_date(entry['date']) <= now_compare \
                and not entry['finished']]
        if not args.quiet:
            if args.pretty:
                for i, item in enumerate(items):
                    sys.stdout.write("\033[0;38;5;%sm%s" % \
                            (PRETTY_COLORS[min(len(PRETTY_COLORS)-1, i)], item))
                    if i < len(items):
                        sys.stdout.write(" ")

                sys.stdout.write("\033[0m\n")
            else:
                print("\n".join(items))
        return 0 if items else 1
    elif args.days is None:
        # no days -> reschedule it based on the last delay used
        if not args.label in db:
            if not args.quiet:
                print("Error: no such label")
            return 1

        entry = db[args.label]
        if entry['last_step'] == '-1':
            entry['finished'] = today
        else:
            entry['date'] = date_offset(entry['last_step'])
        db_write(args.file, db)
    else:
        count = int(db.get(args.label, dict()).get('count', 0)) + 1
        date = date_offset(args.days)
        db[args.label] = dict(label=args.label, date=date, count=count, last_step=args.days)
        db_write(args.file, db)

if __name__ == '__main__':
    sys.exit(main())
