#!/usr/bin/python
# -*- coding: utf-8 -*-
import argparse
import copy
import pprint
import re

CHAPTERNAME_RE = re.compile(r'^#+ ((?:\d+\.)+) (.*?)(\s*\(kein eigener Testfall\))?(\s*\(kein Titel\))?(\s*\(ein mal reicht\))?(\s*\(Testfall\))?$')
LINE_RE = re.compile(r'^\d+\. (.*)$')
REFERENCE_RE = re.compile(r'^Führe ((?:\d+\.)+)\s*(?:\([^)]*\))?\sdurch(\s*\(Vorbedingung\))?$')
TITLE_TEMPLATE = '## ☐ &nbsp; %s'
MAX_DEREFERENCES = 100


def extract_chapters(text):
    chapters = {}
    chapter = None
    for line in text.split('\n'):
        line = line
        match = CHAPTERNAME_RE.match(line)
        if match:
            chapter = match.group(1)
            title = match.group(2)
            intended_to_be_included = bool(match.group(3))
            was_included = False
            if intended_to_be_included:
                was_included = True
            display_title = not bool(match.group(4))
            only_once = bool(match.group(5))
            testcase_title = bool(match.group(6))

            if chapter in chapters:
                raise Exception("Duplicate chapter: %s" % chapter)
            chapters[chapter] = dict(title=title, content=[], content_before=[], was_included=was_included, display_title=display_title, only_once=only_once, included_once=False, testcase_title=title if testcase_title else None)
        elif chapter:
            if line:
                match = LINE_RE.match(line)
                if match:
                    chapters[chapter]['content'].append(match.group(1))
                else:
                    chapters[chapter]['content'].append(line)
    return chapters


def dereference(orig_chapters):
    chapters = copy.deepcopy(orig_chapters)
    count_dereferences = 0

    def recursive_dereference(chapter, depth=0):
        chapter = copy.deepcopy(chapter)

        if depth >= MAX_DEREFERENCES:
            return chapter

        inserted_own_title = False
        content = chapter['content']
        i = 0
        while i < len(content):
            match = REFERENCE_RE.match(content[i])
            if match:
                reference = match.group(1)
                chapters[reference]['was_included'] = True
                chap = orig_chapters[reference]
                if chap['only_once'] and chap['included_once']:
                    content[i:i+1] = ["Ignored chapter %s" % reference]
                    continue
                else:
                    chap['included_once'] = True
                dereferenced_chap = recursive_dereference(chap, depth=depth+1)
                added_content = dereferenced_chap['content']

                # Add the title
                if chapter['display_title']:
                    title = TITLE_TEMPLATE % chap['title']
                    #added_content.insert(0, title + ' (Y)')
                    #added_content.insert(1, "")
                    if not inserted_own_title:
                        if match.group(2):
                            added_content.append(TITLE_TEMPLATE % chapter['title'])
                            added_content.append("")
                        else:
                            added_content.insert(0, TITLE_TEMPLATE % chapter['title'])
                            added_content.insert(0, "")
                        inserted_own_title = True

                content[i:i+1] = added_content
            else:
                if i == 0 and not inserted_own_title and chapter['display_title']:
                    content.insert(0, TITLE_TEMPLATE % chapter['title'])
                    content.insert(1, "")
                    inserted_own_title = True
                    i += 2
                i += 1
        return chapter


    for data in chapters.values():
        data['content'] = recursive_dereference(data)['content']
    return chapters


def select(chapters):
    chapters = copy.deepcopy(chapters)
    keys = list(chapters)
    for chapter in keys:
        if chapters[chapter]['was_included']:
            del chapters[chapter]
        elif not chapters[chapter]['content']:
            del chapters[chapter]
    return chapters


def display(chapters):
    chapternames = chapters.keys()
    chapternames.sort()
    #chapternames.sort(key=lambda key: -len(chapters[key]['content']))
    index = []
    print("# Index")
    for i, chaptername in enumerate(chapternames):
        chapter = chapters[chaptername]
        title = chapter['testcase_title'] if chapter['testcase_title'] else ('Testfall #%d' % i + 1)
        print("0. [%s](#%d)" % (title, i+1))
    print('')

    for i, chaptername in enumerate(chapternames):
        chapter = chapters[chaptername]

        #print("# Testfall #%d/%d (%s)" % (i + 1, len(chapters), chaptername))
        title = ''
        title += "<span id='%d'></span>\n\n" % (i + 1)
        title += "# Testfall #%d/%d" % (i + 1, len(chapters))
        if chapter['testcase_title']:
            title += ': %s' % chapter['testcase_title']
        #title += ' (%s)' % chaptername
        print(title)
        print("")
        j = 1
        needs_space = False
        for line in chapter['content']:
            if line.startswith('#'):
                if needs_space:
                    print("")
                print(line)
                needs_space = False
            elif line.startswith(' ') or line == "":
                print(line)
            else:
                if line.startswith('-> '):
                    line = re.sub(r'^-> ', '☐ ', line)
                print('%d. %s' % (j, line))
                j += 1
                needs_space = True

        if i < len(chapters) - 1:
            print("")
            print("")
            print("")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('positionals', nargs='*')
    args = parser.parse_args()

    sourcefile = args.positionals[0]
    text = open(sourcefile, 'r').read()
    chapters = extract_chapters(text)
    chapters = dereference(chapters)
    chapters = select(chapters)
    display(chapters)


if __name__ == '__main__':
    main()
